<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Compare Nodes - BeanPing</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            animation: {
              "fade-in": "fadeIn 0.5s ease-in-out",
            },
            keyframes: {
              fadeIn: {
                "0%": { opacity: "0" },
                "100%": { opacity: "1" },
              },
            },
          },
        },
      };
    </script>
    <style>
      .glass-morphism {
        /* FIX: Increased opacity to 0.95 for a "fogged glass" effect */
        background: rgba(30, 41, 59, 0.95);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .mesh-bg {
        background: linear-gradient(
          135deg,
          #1e293b 0%,
          #0f172a 50%,
          #1e1b4b 100%
        );
      }
      canvas {
        width: 100% !important;
        height: 300px !important;
      }
      .btn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 16px;
        border-radius: 8px;
        font-weight: 500;
        font-size: 14px;
        transition: all 0.2s;
        cursor: pointer;
        border: none;
        color: #e2e8f0;
      }
      .btn-sm {
        padding: 6px 12px;
        font-size: 12px;
      }
    </style>
  </head>
  <body
    class="min-h-screen mesh-bg text-slate-200 overflow-x-hidden p-4 md:p-8"
  >
    <!-- Background elements -->
    <div class="fixed inset-0 overflow-hidden pointer-events-none -z-10">
      <div
        class="absolute -top-40 -right-40 w-96 h-96 bg-purple-600 rounded-full mix-blend-screen filter blur-3xl opacity-20"
      ></div>
      <div
        class="absolute -bottom-40 -left-40 w-96 h-96 bg-blue-600 rounded-full mix-blend-screen filter blur-3xl opacity-20"
      ></div>
    </div>

    <div class="max-w-7xl mx-auto space-y-6 animate-fade-in">
      <!-- Header -->
      <header class="flex flex-wrap justify-between items-center gap-4">
        <h1
          class="text-4xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent"
        >
          Compare Nodes
        </h1>
        <a
          href="/"
          class="btn glass-morphism hover:bg-white/10 transition-all duration-300 flex items-center gap-2 font-semibold"
        >
          <svg class="w-5 h-5" fill="currentColor">
            <use xlink:href="/icons.svg#icon-back" />
          </svg>
          Back to Dashboard
        </a>
      </header>

      <!-- Node Selection -->
      <div class="glass-morphism rounded-2xl p-6 shadow-2xl relative z-10">
        <h2 class="text-lg font-semibold text-blue-300 mb-4">
          Select Nodes to Compare
        </h2>
        <div class="relative max-w-md">
          <svg
            class="w-5 h-5 text-slate-400 absolute left-4 top-1/2 -translate-y-1/2 pointer-events-none"
            fill="currentColor"
          >
            <use href="icons.svg#icon-search"></use>
          </svg>
          <input
            type="text"
            id="nodeSearch"
            placeholder="Search nodes by name or IP..."
            autocomplete="off"
            class="w-full pl-11 pr-4 py-3 glass-morphism rounded-xl focus:ring-2 focus:ring-blue-500 focus:outline-none transition"
          />
          <div
            id="nodeDropdown"
            class="hidden absolute top-full left-0 right-0 mt-2 glass-morphism rounded-xl shadow-2xl max-h-60 overflow-y-auto z-50"
          ></div>
        </div>

        <div id="selectedNodes" class="flex flex-wrap gap-2 mt-4"></div>

        <div
          class="flex justify-between items-center mt-4 border-t border-white/10 pt-4"
        >
          <span class="text-slate-400 text-sm" id="selectionCount"
            >0 nodes selected</span
          >
          <button
            onclick="clearSelection()"
            class="btn btn-sm glass-morphism hover:bg-white/10"
          >
            Clear All
          </button>
        </div>
      </div>

      <!-- Controls -->
      <div
        id="controlsSection"
        class="glass-morphism rounded-2xl p-4 md:p-6 flex items-center gap-4 flex-wrap"
      >
        <label class="text-slate-300 font-medium">Time Range:</label>
        <select
          id="timeRange"
          class="glass-morphism px-3 py-2 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition"
        >
          <option value="1 HOUR" selected>Last Hour</option>
          <option value="1 DAY">Last Day</option>
          <option value="7 DAYS">Last Week</option>
          <option value="1 MONTH">Last Month</option>
          <option value="3 MONTHS">Last 3 Months</option>
        </select>
        <button
          id="pauseBtn"
          class="btn btn-sm glass-morphism hover:bg-white/10"
        >
          <svg class="w-4 h-4" fill="currentColor">
            <use xlink:href="/icons.svg#icon-pause" />
          </svg>
          Pause
        </button>
        <span class="text-slate-400 text-sm flex items-center gap-2 ml-auto">
          <svg class="w-4 h-4" fill="currentColor">
            <use xlink:href="/icons.svg#icon-warning" />
          </svg>
          Drag to zoom, rightâ€‘click to reset
        </span>
      </div>

      <!-- Charts Section -->
      <div id="chartsSection" class="space-y-6">
        <div class="glass-morphism rounded-2xl p-4 md:p-6">
          <div class="flex justify-between items-start mb-4">
            <h2 class="text-lg font-semibold text-blue-300">
              Latency Comparison (ms)
            </h2>
            <div class="text-sm" id="latencyLegend"></div>
          </div>
          <canvas id="latencyChart"></canvas>
        </div>

        <div class="glass-morphism rounded-2xl p-4 md:p-6">
          <div class="flex justify-between items-start mb-4">
            <h2 class="text-lg font-semibold text-red-400">
              Packet Loss Comparison (%)
            </h2>
            <div class="text-sm" id="lossLegend"></div>
          </div>
          <canvas id="lossChart"></canvas>
        </div>

        <div class="glass-morphism rounded-2xl p-4 md:p-6">
          <div class="flex justify-between items-start mb-4">
            <h2 class="text-lg font-semibold text-green-400">
              Jitter Comparison (ms)
            </h2>
            <div class="text-sm" id="jitterLegend"></div>
          </div>
          <canvas id="jitterChart"></canvas>
        </div>
      </div>
    </div>

    <script>
      let charts = [];
      let selectedNodes = new Map();
      let liveUpdatesPaused = false;
      let allNodes = [];
      let filteredNodes = [];

      <% const nodesJson = JSON.stringify(nodes); %>
      allNodes = <%- nodesJson %>;
      filteredNodes = [...allNodes];

      const colors = ['#60a5fa', '#f87171', '#4ade80', '#facc15', '#a78bfa', '#22d3ee', '#fb923c', '#a3e635', '#f472b6', '#818cf8', '#2dd4bf', '#f43f5e', '#c084fc', '#34d399', '#f59e0b'];

      const searchInput = document.getElementById('nodeSearch');
      const dropdown = document.getElementById('nodeDropdown');

      function filterNodes(query) {
        const q = query.toLowerCase().trim();
        filteredNodes = !q ? [...allNodes] : allNodes.filter(node => node.name.toLowerCase().includes(q) || node.ip.toLowerCase().includes(q));
        renderDropdown();
      }

      function renderDropdown() {
        if (filteredNodes.length === 0) {
          dropdown.innerHTML = '<div class="px-4 py-3 text-center text-slate-400">No nodes found</div>';
        } else {
          dropdown.innerHTML = filteredNodes.map(node => `
            <div class="flex items-center justify-between px-4 py-3 cursor-pointer hover:bg-white/10 transition ${selectedNodes.has(node.id) ? 'bg-blue-500/10' : ''}" 
                 data-node-id="${node.id}" 
                 onclick="toggleNode(${node.id}, '${node.name}', '${node.ip}')">
              <div>
                <div class="font-medium text-slate-100">${node.name}</div>
                <div class="text-sm text-slate-400">${node.ip}</div>
              </div>
              ${selectedNodes.has(node.id) ? '<svg class="w-5 h-5 text-green-400" fill="currentColor"><use href="icons.svg#icon-check-circle"></use></svg>' : ''}
            </div>
          `).join('');
        }
      }

      function showDropdown() {
        renderDropdown();
        dropdown.style.display = 'block';
      }

      function hideDropdown() {
        setTimeout(() => {
          if (document.activeElement !== searchInput) {
            dropdown.style.display = 'none';
          }
        }, 200);
      }

      searchInput.addEventListener('focus', showDropdown);
      searchInput.addEventListener('blur', hideDropdown);
      searchInput.addEventListener('input', (e) => {
        filterNodes(e.target.value);
        showDropdown();
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.relative.max-w-md')) {
          dropdown.style.display = 'none';
        }
      });

      function toggleNode(nodeId, nodeName, nodeIp) {
        if (selectedNodes.has(nodeId)) {
          selectedNodes.delete(nodeId);
        } else {
          selectedNodes.set(nodeId, { id: nodeId, name: nodeName, ip: nodeIp });
        }
        updateSelectedNodesDisplay();
        renderDropdown();
        loadComparison();
      }

      function updateSelectedNodesDisplay() {
        const container = document.getElementById('selectedNodes');
        const countEl = document.getElementById('selectionCount');
        container.innerHTML = '';
        selectedNodes.forEach((node, nodeId) => {
          const tag = document.createElement('div');
          tag.className = 'flex items-center gap-2 text-sm bg-green-500/20 border border-green-500/30 text-green-300 px-3 py-1 rounded-full';
          tag.innerHTML = `
            <span>${node.name}</span>
            <button onclick="toggleNode(${nodeId}, '${node.name}', '${node.ip}')" class="hover:bg-white/20 rounded-full w-4 h-4 flex items-center justify-center text-xs">&times;</button>
          `;
          container.appendChild(tag);
        });
        const count = selectedNodes.size;
        countEl.textContent = `${count} node${count !== 1 ? 's' : ''} selected`;
      }

      function clearSelection() {
        selectedNodes.clear();
        updateSelectedNodesDisplay();
        renderDropdown();
        loadComparison();
        searchInput.value = '';
        filterNodes('');
      }

      function createGradient(ctx, color) {
        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, color + '20');
        gradient.addColorStop(1, color + '00');
        return gradient;
      }

      function getTimeWindow(range) {
        const now = Date.now();
        switch (range) {
          case "1 HOUR": return { min: now - 60 * 60 * 1000, max: now };
          case "1 DAY": return { min: now - 24 * 60 * 60 * 1000, max: now };
          case "7 DAYS": return { min: now - 7 * 24 * 60 * 60 * 1000, max: now };
          case "1 MONTH": return { min: now - 30 * 24 * 60 * 60 * 1000, max: now };
          case "3 MONTHS": return { min: now - 90 * 24 * 60 * 60 * 1000, max: now };
          default: return { min: null, max: null };
        }
      }

      function createLegend(containerId, datasets) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        datasets.forEach((dataset) => {
          const legendItem = document.createElement('div');
          legendItem.className = 'flex items-center gap-2 mb-1';
          legendItem.innerHTML = `
            <div class="w-4 h-1 rounded-full" style="background-color: ${dataset.borderColor}"></div>
            <span class="text-slate-300 text-xs">${dataset.label}</span>
          `;
          container.appendChild(legendItem);
        });
      }

      async function loadComparison() {
        const range = document.getElementById('timeRange').value;
        const { min, max } = getTimeWindow(range);
        
        charts.forEach(chart => chart.destroy());
        charts = [];
        
        let nodeDatasets = [];
        
        if (selectedNodes.size > 0) {
          const nodeDataPromises = Array.from(selectedNodes.values()).map(async (node, index) => {
            const res = await fetch(`/api/nodes/${node.id}/stats?range=${encodeURIComponent(range)}`);
            const data = await res.json();
            const color = colors[index % colors.length];
            return {
              node, color,
              latencyData: data.map(d => ({ x: new Date(d.timestamp).getTime(), y: d.latency })),
              lossData: data.map(d => ({ x: new Date(d.timestamp).getTime(), y: d.packet_loss ?? 0 })),
              jitterData: data.map(d => ({ x: new Date(d.timestamp).getTime(), y: d.jitter })),
            };
          });
          nodeDatasets = await Promise.all(nodeDataPromises);
        }
        
        const baseOptions = {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: true,
              backgroundColor: "rgba(15, 23, 42, 0.8)",
              borderColor: "rgba(255, 255, 255, 0.1)",
              borderWidth: 1,
              titleFont: { weight: "bold" },
              padding: 10,
            },
            zoom: {
              zoom: {
                drag: { enabled: true, backgroundColor: "rgba(96, 165, 250, 0.2)", borderColor: "#60a5fa" },
                mode: "x",
              },
            },
          },
          scales: {
            x: {
              type: "time", min, max,
              time: { tooltipFormat: "MMM d, HH:mm:ss", displayFormats: { minute: "HH:mm", hour: "MMM d HH:mm", day: "MMM d", month: "MMM yyyy" } },
              ticks: { color: "#94a3b8" }, grid: { color: "rgba(255,255,255,0.05)" },
            },
            y: {
              beginAtZero: true,
              ticks: { color: "#94a3b8", precision: 2 }, grid: { color: "rgba(255,255,255,0.1)" },
            },
          },
        };

        const chartConfigs = [
            { id: 'latencyChart', legendId: 'latencyLegend', dataKey: 'latencyData' },
            { id: 'lossChart', legendId: 'lossLegend', dataKey: 'lossData' },
            { id: 'jitterChart', legendId: 'jitterLegend', dataKey: 'jitterData' }
        ];

        chartConfigs.forEach(config => {
            // FIX: Create a deep copy of baseOptions for each chart to prevent reference sharing
            const chartOptions = JSON.parse(JSON.stringify(baseOptions));

            // Apply specific modifications if needed
            if (config.id === 'lossChart') {
                chartOptions.scales.y.min = 0;
                chartOptions.scales.y.max = 100;
            }

            const datasets = nodeDatasets.map(d => ({
                label: `${d.node.name}`,
                data: d[config.dataKey],
                borderColor: d.color,
                backgroundColor: createGradient(document.getElementById(config.id).getContext("2d"), d.color),
                fill: false, tension: 0.4, pointRadius: 0, spanGaps: false, borderWidth: 2,
            }));
            
            const ctx = document.getElementById(config.id).getContext("2d");
            charts.push(new Chart(ctx, { type: "line", data: { datasets }, options: chartOptions }));
            createLegend(config.legendId, datasets);
        });
      }

      loadComparison();

      document.addEventListener("contextmenu", (e) => {
        // Find which chart was clicked
        const clickedChart = charts.find((c) => c.canvas.contains(e.target));
        if (clickedChart) {
          e.preventDefault();
          // Reset only the clicked chart
          clickedChart.resetZoom();
        }
      });

      document.getElementById("timeRange").addEventListener("change", loadComparison);
      
      document.getElementById("pauseBtn").addEventListener("click", () => {
        liveUpdatesPaused = !liveUpdatesPaused;
        const btn = document.getElementById("pauseBtn");
        if (liveUpdatesPaused) {
          btn.innerHTML = `<svg class="w-4 h-4" fill="currentColor"><use xlink:href="/icons.svg#icon-resume" /></svg> Resume`;
          btn.classList.add("text-green-400");
        } else {
          btn.innerHTML = `<svg class="w-4 h-4" fill="currentColor"><use xlink:href="/icons.svg#icon-pause" /></svg> Pause`;
          btn.classList.remove("text-green-400");
          loadComparison();
        }
      });

      const socket = io();
      socket.on("pingUpdate", (data) => {
        if (!liveUpdatesPaused && selectedNodes.has(data.nodeId)) {
          const range = document.getElementById('timeRange').value;
          const { min, max } = getTimeWindow(range);
          const ts = new Date(data.timestamp).getTime();
          
          const nodeIndex = Array.from(selectedNodes.keys()).indexOf(data.nodeId);
          
          if (nodeIndex !== -1 && charts.length === 3) {
            const values = [
              data.latency !== null ? data.latency : null,
              data.packetLoss ?? 0,
              data.jitter !== null ? data.jitter : null
            ];
            
            values.forEach((val, chartIndex) => {
              const chart = charts[chartIndex];
              if (!chart || !chart.data.datasets[nodeIndex]) return;
              
              const dataset = chart.data.datasets[nodeIndex].data;
              dataset.push({ x: ts, y: val });
              chart.data.datasets[nodeIndex].data = dataset.filter((p) => p.x >= min);
              
              chart.options.scales.x.min = min;
              chart.options.scales.x.max = max;
              chart.update("none");
            });
          }
        }
      });
    </script>
  </body>
</html>